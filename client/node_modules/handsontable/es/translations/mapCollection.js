import "core-js/modules/es.array.from";
import "core-js/modules/es.array.iterator";
import "core-js/modules/es.map";
import "core-js/modules/es.object.to-string";
import "core-js/modules/es.string.iterator";
import "core-js/modules/web.dom-collections.for-each";
import "core-js/modules/web.dom-collections.iterator";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

import { isUndefined, isDefined } from '../helpers/mixed';
import { mixin } from '../helpers/object';
import localHooks from '../mixins/localHooks'; // Counter for checking if there is a memory leak.

var registeredMaps = 0;

var MapCollection =
/*#__PURE__*/
function () {
  function MapCollection() {
    _classCallCheck(this, MapCollection);

    this.mappings = new Map();
  }
  /**
   * Register custom index map.
   *
   * @param {String} uniqueName Unique name of the indexes list.
   * @param {BaseMap} map Map containing miscellaneous (i.e. meta data, indexes sequence), updated after remove and insert data actions.
   * @returns {BaseMap|undefined}
   */


  _createClass(MapCollection, [{
    key: "register",
    value: function register(uniqueName, map) {
      var _this = this;

      if (this.mappings.has(uniqueName) === false) {
        this.mappings.set(uniqueName, map);
        map.addLocalHook('change', function () {
          return _this.runLocalHooks('change', map);
        });
        registeredMaps += 1;
      }
    }
    /**
     * Unregister custom index map.
     *
     * @param {String} name Name of the indexes list.
     */

  }, {
    key: "unregister",
    value: function unregister(name) {
      var map = this.mappings.get(name);

      if (isDefined(map)) {
        map.clearLocalHooks();
        this.mappings.delete(name);
        this.runLocalHooks('change', map);
        registeredMaps -= 1;
      }
    }
    /**
     * Get indexes list for provided index map name.
     *
     * @param {String} [name] Name of the indexes list.
     * @returns {Array|IndexMap}
     */

  }, {
    key: "get",
    value: function get(name) {
      if (isUndefined(name)) {
        return Array.from(this.mappings.values());
      }

      return this.mappings.get(name);
    }
    /**
     * Get collection size.
     *
     * @returns {Number}
     */

  }, {
    key: "getLength",
    value: function getLength() {
      return this.mappings.size;
    }
    /**
     * Remove some indexes and corresponding mappings and update values of the others within all collection's index maps.
     *
     * @private
     * @param {Array} removedIndexes List of removed indexes.
     */

  }, {
    key: "removeFromEvery",
    value: function removeFromEvery(removedIndexes) {
      this.mappings.forEach(function (list) {
        list.remove(removedIndexes);
      });
    }
    /**
     * Insert new indexes and corresponding mapping and update values of the others all collection's index maps.
     *
     * @private
     * @param {Number} firstInsertedVisualIndex First inserted visual index.
     * @param {Number} firstInsertedPhysicalIndex First inserted physical index.
     * @param {Number} amountOfIndexes Amount of inserted indexes.
     */

  }, {
    key: "insertToEvery",
    value: function insertToEvery(insertionIndex, insertedIndexes) {
      this.mappings.forEach(function (list) {
        list.insert(insertionIndex, insertedIndexes);
      });
    }
    /**
     * Set default values to index maps within collection.
     *
     * @param {Number} length Destination length for all stored index maps.
     */

  }, {
    key: "initEvery",
    value: function initEvery(length) {
      this.mappings.forEach(function (list) {
        list.init(length);
      });
    }
  }]);

  return MapCollection;
}();

mixin(MapCollection, localHooks);
export default MapCollection;
export function getRegisteredMapsCounter() {
  return registeredMaps;
}