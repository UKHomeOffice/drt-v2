import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import { GRID_CHECKBOX_SELECTION_COL_DEF } from '../../../../colDef';
import { buildWarning } from '../../../../utils/warning';
function sanitizeCellValue(value, csvOptions) {
  if (typeof value === 'string') {
    if (csvOptions.shouldAppendQuotes || csvOptions.escapeFormulas) {
      var escapedValue = value.replace(/"/g, '""');
      // Make sure value containing delimiter or line break won't be split into multiple cells
      if ([csvOptions.delimiter, '\n', '\r', '"'].some(function (delimiter) {
        return value.includes(delimiter);
      })) {
        return "\"".concat(escapedValue, "\"");
      }
      if (csvOptions.escapeFormulas) {
        // See https://owasp.org/www-community/attacks/CSV_Injection
        if (['=', '+', '-', '@', '\t', '\r'].includes(escapedValue[0])) {
          return "'".concat(escapedValue);
        }
      }
      return escapedValue;
    }
    return value;
  }
  return value;
}
export var serializeCellValue = function serializeCellValue(cellParams, options) {
  var csvOptions = options.csvOptions,
    ignoreValueFormatter = options.ignoreValueFormatter;
  var value;
  if (ignoreValueFormatter) {
    var _cellParams$value2;
    var columnType = cellParams.colDef.type;
    if (columnType === 'number') {
      value = String(cellParams.value);
    } else if (columnType === 'date' || columnType === 'dateTime') {
      var _cellParams$value;
      value = (_cellParams$value = cellParams.value) == null ? void 0 : _cellParams$value.toISOString();
    } else if (typeof ((_cellParams$value2 = cellParams.value) == null ? void 0 : _cellParams$value2.toString) === 'function') {
      value = cellParams.value.toString();
    } else {
      value = cellParams.value;
    }
  } else {
    value = cellParams.formattedValue;
  }
  return sanitizeCellValue(value, csvOptions);
};
var objectFormattedValueWarning = buildWarning(['MUI: When the value of a field is an object or a `renderCell` is provided, the CSV export might not display the value correctly.', 'You can provide a `valueFormatter` with a string representation to be used.']);
var CSVRow = /*#__PURE__*/function () {
  function CSVRow(options) {
    _classCallCheck(this, CSVRow);
    this.options = void 0;
    this.rowString = '';
    this.isEmpty = true;
    this.options = options;
  }
  _createClass(CSVRow, [{
    key: "addValue",
    value: function addValue(value) {
      if (!this.isEmpty) {
        this.rowString += this.options.csvOptions.delimiter;
      }
      if (value === null || value === undefined) {
        this.rowString += '';
      } else if (typeof this.options.sanitizeCellValue === 'function') {
        this.rowString += this.options.sanitizeCellValue(value, this.options.csvOptions);
      } else {
        this.rowString += value;
      }
      this.isEmpty = false;
    }
  }, {
    key: "getRowString",
    value: function getRowString() {
      return this.rowString;
    }
  }]);
  return CSVRow;
}();
var serializeRow = function serializeRow(_ref) {
  var id = _ref.id,
    columns = _ref.columns,
    getCellParams = _ref.getCellParams,
    csvOptions = _ref.csvOptions,
    ignoreValueFormatter = _ref.ignoreValueFormatter;
  var row = new CSVRow({
    csvOptions: csvOptions
  });
  columns.forEach(function (column) {
    var cellParams = getCellParams(id, column.field);
    if (process.env.NODE_ENV !== 'production') {
      if (String(cellParams.formattedValue) === '[object Object]') {
        objectFormattedValueWarning();
      }
    }
    row.addValue(serializeCellValue(cellParams, {
      ignoreValueFormatter: ignoreValueFormatter,
      csvOptions: csvOptions
    }));
  });
  return row.getRowString();
};
export function buildCSV(options) {
  var columns = options.columns,
    rowIds = options.rowIds,
    csvOptions = options.csvOptions,
    ignoreValueFormatter = options.ignoreValueFormatter,
    apiRef = options.apiRef;
  var CSVBody = rowIds.reduce(function (acc, id) {
    return "".concat(acc).concat(serializeRow({
      id: id,
      columns: columns,
      getCellParams: apiRef.current.getCellParams,
      ignoreValueFormatter: ignoreValueFormatter,
      csvOptions: csvOptions
    }), "\r\n");
  }, '').trim();
  if (!csvOptions.includeHeaders) {
    return CSVBody;
  }
  var filteredColumns = columns.filter(function (column) {
    return column.field !== GRID_CHECKBOX_SELECTION_COL_DEF.field;
  });
  var headerRows = [];
  if (csvOptions.includeColumnGroupsHeaders) {
    var columnGroupLookup = apiRef.current.unstable_getAllGroupDetails();
    var maxColumnGroupsDepth = 0;
    var columnGroupPathsLookup = filteredColumns.reduce(function (acc, column) {
      var columnGroupPath = apiRef.current.unstable_getColumnGroupPath(column.field);
      acc[column.field] = columnGroupPath;
      maxColumnGroupsDepth = Math.max(maxColumnGroupsDepth, columnGroupPath.length);
      return acc;
    }, {});
    var _loop = function _loop(i) {
      var headerGroupRow = new CSVRow({
        csvOptions: csvOptions,
        sanitizeCellValue: sanitizeCellValue
      });
      headerRows.push(headerGroupRow);
      filteredColumns.forEach(function (column) {
        var columnGroupId = (columnGroupPathsLookup[column.field] || [])[i];
        var columnGroup = columnGroupLookup[columnGroupId];
        headerGroupRow.addValue(columnGroup ? columnGroup.headerName || columnGroup.groupId : '');
      });
    };
    for (var i = 0; i < maxColumnGroupsDepth; i += 1) {
      _loop(i);
    }
  }
  var mainHeaderRow = new CSVRow({
    csvOptions: csvOptions,
    sanitizeCellValue: sanitizeCellValue
  });
  filteredColumns.forEach(function (column) {
    mainHeaderRow.addValue(column.headerName || column.field);
  });
  headerRows.push(mainHeaderRow);
  var CSVHead = "".concat(headerRows.map(function (row) {
    return row.getRowString();
  }).join('\r\n'), "\r\n");
  return "".concat(CSVHead).concat(CSVBody).trim();
}